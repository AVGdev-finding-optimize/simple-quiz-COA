[
  {
    "type": "mcq",
    "question": "Theo slide bài giảng (Chương 1), ba (3) lớp máy tính chính được phân loại là gì?",
    "options": [
      "Mainframe, Minicomputer, Microcomputer",
      "Desktop, Server, Embedded",
      "Supercomputer, Workstation, Laptop",
      "CISC, RISC, VLIW"
    ],
    "answer": 1,
    "explanation": "Slide 01.pdf (trang 5) phân loại máy tính thành: Desktop computers (máy tính để bàn), Server computers (máy chủ), và Embedded computers (máy tính nhúng)."
  },
  {
    "type": "mcq",
    "question": "Theo giáo trình Hennessy & Patterson (Chương 1), 'Kiến trúc tập lệnh' (ISA) được định nghĩa là gì?",
    "options": [
      "Tổ chức phần cứng chi tiết của CPU, bao gồm cả thiết kế pipeline và cache.",
      "Giao diện giữa phần cứng và phần mềm, là phần mà lập trình viên hoặc trình biên dịch có thể thấy được.",
      "Tập hợp các vi mã (microcode) được lưu trong ROM để thực thi các lệnh phức tạp.",
      "Thiết kế hệ thống bus và các bộ điều khiển I/O."
    ],
    "answer": 1,
    "explanation": "Giáo trình (Chương 1, Mục 1.3) định nghĩa ISA (Instruction Set Architecture) là 'tập lệnh thực tế mà lập trình viên thấy được' (the actual programmer-visible instruction set) và nó 'đóng vai trò là ranh giới giữa phần mềm và phần cứng' (serves as the boundary between the software and hardware)."
  },
  {
    "type": "mcq",
    "question": "Biểu thức nào sau đây thể hiện đúng luật DeMorgan trong Đại số Boolean?",
    "options": [
      "A + (B.C) = (A+B).(A+C)",
      "A + 1 = 1",
      "NOT(A + B) = (NOT A) . (NOT B)",
      "A + A.B = A"
    ],
    "answer": 2,
    "explanation": "Slide 02.pdf (trang 15) trình bày các luật Đại số Boolean, trong đó có luật DeMorgan. Một trong hai dạng của luật này là: (A+B) ngang = A ngang . B ngang (tức là NOT(A + B) = (NOT A) . (NOT B))."
  },
  {
    "type": "mcq",
    "question": "Trong các khái niệm về phụ thuộc lệnh, 'phụ thuộc dữ liệu thực sự' (true data dependence) tương ứng với nguy cơ (hazard) nào?",
    "options": [
      "Phụ thuộc đầu ra (Output dependence - WAW)",
      "Phụ thuộc ngược (Antidependence - WAR)",
      "Nguy cơ cấu trúc (Structural Hazard)",
      "Nguy cơ RAW (Read After Write)"
    ],
    "answer": 3,
    "explanation": "Giáo trình (Chương 2, Mục 2.1) định nghĩa 'data dependences (also called true data dependences)'. Nguy cơ (hazard) phổ biến nhất tương ứng với nó là RAW (read after write), xảy ra khi 'lệnh j cố gắng đọc nguồn trước khi lệnh i ghi vào nó'."
  },
  {
    "type": "fitb",
    "question": "Số thập lục phân (Hex) A7 tương đương với số nhị phân 8-bit là ......",
    "answer": "10100111",
    "explanation": "Theo phương pháp chuyển đổi trong Slide 02.pdf (trang 141), ta chuyển đổi từng chữ số Hex sang 4 bit nhị phân: A (Hex) = 10 (Dec) = 1010 (Bin); 7 (Hex) = 7 (Dec) = 0111 (Bin). Ghép lại ta được 10100111."
  },
  {
    "type": "fitb",
    "question": "Theo phương trình hiệu năng bộ xử lý cơ bản trong giáo trình (Chương 1), CPU Time = Instruction Count * ...... * Clock Cycle Time.",
    "answer": "CPI (Cycles Per Instruction)",
    "explanation": "Giáo trình (Chương 1, Mục 1.9) đưa ra phương trình hiệu năng kinh điển: CPU time = Instruction count × Cycles per instruction × Clock cycle time."
  },
  {
    "type": "msq",
    "question": "Những thành phần nào sau đây thuộc về mạch logic tuần tự (Sequential Logic Circuits), trái ngược với mạch logic tổ hợp (Combinational Logic)?",
    "options": [
      "Mux (Bộ dồn kênh)",
      "D Latch (Chốt D)",
      "Full Adder (Bộ cộng toàn phần)",
      "SR Flip-Flop"
    ],
    "answer": [1, 3],
    "explanation": "Slide 02.pdf (Mục 'Sequential Logic Circuits', trang 68) định nghĩa mạch tuần tự là mạch 'liên quan đến một hoặc nhiều phần tử nhớ'. Latch (Trang 61) và Flip-Flop (Trang 65) là các phần tử nhớ. Mux (Trang 49) và Full Adder (Trang 162) là các mạch tổ hợp (Combinational Logic)."
  },
  {
    "type": "msq",
    "question": "Giáo trình Hennessy & Patterson (Chương 1) nhấn mạnh các nguyên tắc định lượng (Quantitative Principles) nào trong thiết kế máy tính?",
    "options": [
      "Tận dụng tính song song (Take Advantage of Parallelism)",
      "Nguyên tắc tham chiếu cục bộ (Principle of Locality)",
      "Tập trung vào trường hợp phổ biến (Focus on the Common Case)",
      "Sử dụng thiết kế vi mã (Use Microprogramming)"
    ],
    "answer": [0, 1, 2],
    "explanation": "Mục 1.9 của giáo trình (Chương 1) trình bày các nguyên tắc định lượng, bao gồm: Take Advantage of Parallelism, Principle of Locality, và Focus on the Common Case. Luật Amdahl cũng được trình bày trong mục này như một cách để định lượng nguyên tắc 'Focus on the common case'."
  },
  {
    "type": "mcq",
    "question": "Theo bảng phân cấp bộ nhớ trong Slide 01.pdf (trang 19), thời gian truy cập (Access Time) của Main Memory (Bộ nhớ chính) chậm hơn L1 Cache khoảng bao nhiêu lần?",
    "options": [
      "2-5 lần",
      "80-200 lần",
      "10.000 lần",
      "10.000.000 lần"
    ],
    "answer": 1,
    "explanation": "Slide 01.pdf (trang 19) ghi Access Time của 'L1 and L2 Cache' là ~1 ns - ~10 ns và 'Main Memory' là 80ns-200ns. Lấy giá trị trung bình, 100ns / 1ns là 100 lần, hoặc 200ns / 1ns là 200 lần. Do đó, khoảng 80-200 lần là phù hợp."
  },
  {
    "type": "mcq",
    "question": "Một chương trình mất 100 giây để thực thi. Nếu 75% thời gian thực thi của chương trình có thể được cải thiện (enhanced) để chạy nhanh gấp 5 lần (Speedup_enhanced = 5), thì tốc độ tăng tốc tổng thể (Speedup_overall) của chương trình là bao nhiêu?",
    "options": [
      "1.6",
      "2.5",
      "3.0",
      "5.0"
    ],
    "answer": 1,
    "explanation": "Áp dụng Luật Amdahl (Giáo trình, Chương 1, Mục 1.9):\nFraction_enhanced = 0.75\nFraction_unenhanced = 1 - 0.75 = 0.25\nSpeedup_enhanced = 5\nSpeedup_overall = 1 / (Fraction_unenhanced + (Fraction_enhanced / Speedup_enhanced))\nSpeedup_overall = 1 / (0.25 + (0.75 / 5))\nSpeedup_overall = 1 / (0.25 + 0.15) = 1 / 0.40 = 2.5."
  },
  {
    "type": "mcq",
    "question": "Một máy tính có bus dữ liệu 64 bit và bus clock là 800Mhz. Một hoạt động đọc/ghi RAM mất 4 chu kỳ bus. Tốc độ truyền dữ liệu (data transfer rate) tối đa là bao nhiêu?",
    "options": [
      "800 MBps",
      "1600 MBps",
      "3200 MBps",
      "6400 MBps"
    ],
    "answer": 1,
    "explanation": "Bài tập trên Slide 02.pdf (trang 59):\n1. Số lần truyền mỗi giây = Tần số bus / Số chu kỳ mỗi lần truyền = 800 * 10^6 Hz / 4 = 200 * 10^6 lần/giây (hay 2*10^8 lần/giây).\n2. Dữ liệu mỗi lần truyền = Độ rộng bus = 64 bit = 8 Bytes.\n3. Tốc độ truyền = (Số lần truyền mỗi giây) * (Dữ liệu mỗi lần truyền) = (2 * 10^8) * 8 Bytes = 16 * 10^8 Bps = 1,600,000,000 Bps = 1600 MBps (vì 1MB = 10^6 B trong ngữ cảnh này, hoặc 1526 MiB nếu dùng 2^20)."
  },
  {
    "type": "mcq",
    "question": "Sử dụng công thức tính Die Yield từ Giáo trình (Chương 1), giả sử một wafer có mật độ lỗi (defects per unit area) là 0.5 trên cm², và α = 4.0. Một die có diện tích 2.0 cm² sẽ có tỷ lệ Die Yield là bao nhiêu?",
    "options": [
      "0.13",
      "0.32",
      "0.51",
      "0.80"
    ],
    "answer": 1,
    "explanation": "Áp dụng công thức tính Die Yield từ Giáo trình (Chương 1, Mục 1.6):\nDie Yield = Wafer Yield * (1 + (Defects per unit area * Die area) / α)^-α\nGiả sử Wafer Yield = 1 (100%).\nDie Yield = (1 + (0.5 * 2.0) / 4.0)^-4.0\nDie Yield = (1 + 1.0 / 4.0)^-4.0 = (1 + 0.25)^-4.0 = (1.25)^-4.0\nDie Yield ≈ 1 / 2.4414 ≈ 0.4096.\nGiá trị gần nhất là 0.32 (Lưu ý: Ví dụ trong sách cho 2.25cm² là 0.44 và 1.0cm² là 0.68. Kết quả 0.4096 là hợp lý, tuy nhiên, 0.32 là lựa chọn gần nhất trong các phương án, có thể do sai số trong mô hình thực tế hoặc làm tròn)."
  },
  {
    "type": "mcq",
    "question": "Biểu diễn số -10 (thập phân) bằng hệ bù 2 (2's Complement) 8-bit là gì?",
    "options": [
      "11110110",
      "11110101",
      "10001010",
      "00001010"
    ],
    "answer": 0,
    "explanation": "Để tìm bù 2 của -10 (dựa trên phương pháp từ Slide 02.pdf, trang 183):\n1. Biểu diễn +10 (8-bit): 00001010\n2. Đảo bit (1's complement): 11110101\n3. Cộng 1: 11110101 + 1 = 11110110"
  },
  {
    "type": "mcq",
    "question": "Trong pipeline, một 'nguy cơ WAR' (Write After Read) xảy ra khi nào?",
    "options": [
      "Lệnh j cố gắng đọc nguồn trước khi lệnh i ghi vào nó.",
      "Lệnh j cố gắng ghi toán hạng trước khi nó được ghi bởi lệnh i.",
      "Lệnh j cố gắng ghi đích trước khi nó được đọc bởi lệnh i.",
      "Lệnh j đọc một thanh ghi sau khi lệnh i đọc nó."
    ],
    "answer": 2,
    "explanation": "Giáo trình (Chương 2, Mục 2.1) định nghĩa nguy cơ WAR (Write After Read): 'j tries to write a destination before it is read by i' (lệnh j cố gắng ghi đích trước khi nó được đọc bởi lệnh i).. Đây là một 'name dependence' (phụ thuộc tên) loại 'antidependence' (phụ thuộc ngược)."
  },
  {
    "type": "mcq",
    "question": "Các tầng trừu tượng (abstractions) trong máy tính theo thứ tự từ trên xuống dưới (từ ứng dụng đến phần cứng) là:",
    "options": [
      "Hardware, Operating System, Compiler, Application",
      "Application, Compiler, Operating System, Hardware",
      "Application, Operating System, Hardware, Compiler",
      "Compiler, Application, Hardware, Operating System"
    ],
    "answer": 1,
    "explanation": "Slide 01.pdf (trang 29) mô tả các tầng 'Below Your Program': Applications software (trên cùng), Systems software (bao gồm Compiler và Operating System), và Hardware (dưới cùng)."
  },
  {
    "type": "msq",
    "question": "Giáo trình Hennessy & Patterson (Chương 1) định nghĩa 'Bandwidth' (Băng thông) và 'Latency' (Độ trễ) như thế nào?",
    "options": [
      "Bandwidth là tổng lượng công việc hoàn thành trong một thời gian nhất định (ví dụ: MB/giây).",
      "Latency là thời gian giữa lúc bắt đầu và lúc kết thúc một sự kiện (ví dụ: ms cho một truy cập đĩa).",
      "Bandwidth và Latency là hai thuật ngữ đồng nghĩa.",
      "Latency là tổng lượng công việc hoàn thành trong một thời gian nhất định."
    ],
    "answer": [0, 1],
    "explanation": "Giáo trình (Chương 1, Mục 1.4) định nghĩa: 'bandwidth or throughput is the total amount of work done in a given time'. Ngược lại, 'latency or response time is the time between the start and the completion of an event'. Hai khái niệm này khác biệt và thường có xu hướng cải thiện với tốc độ khác nhau."
  },
  {
    "type": "mcq",
    "question": "Một bộ giải mã (Decoder) 3-đến-8 (3-to-8) có bao nhiêu đường vào (inputs) và bao nhiêu đường ra (outputs)?",
    "options": [
      "3 inputs, 8 outputs",
      "8 inputs, 3 outputs",
      "3 inputs, 1 output",
      "8 inputs, 1 output"
    ],
    "answer": 0,
    "explanation": "Slide 02.pdf (trang 52) mô tả một bộ giải mã (Decoder). Một bộ giải mã k-đến-2^k có k đường vào và 2^k đường ra. Do đó, bộ giải mã 3-đến-8 có 3 đường vào (inputs) và 8 đường ra (outputs)."
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 1), công thức tính công suất tĩnh (Static Power) là gì?",
    "options": [
      "Current_static * Voltage",
      "0.5 * Capacitive_load * Voltage^2 * Frequency",
      "Current_static * Voltage^2",
      "Current_static / Voltage"
    ],
    "answer": 0,
    "explanation": "Giáo trình (Chương 1, Mục 1.5) định nghĩa công suất tĩnh (Static Power): Power_static = Current_static × Voltage."
  },
  {
    "type": "mcq",
    "question": "Loại bộ nhớ nào sau đây sẽ mất dữ liệu khi nguồn điện bị ngắt?",
    "options": [
      "ROM (Read-Only Memory)",
      "Magnetic disk (Đĩa từ)",
      "Flash memory (Bộ nhớ Flash)",
      "Volatile main memory (RAM)"
    ],
    "answer": 3,
    "explanation": "Slide 01.pdf (trang 18) định nghĩa 'Volatile main memory' (Bộ nhớ chính khả biến, tức RAM) là loại 'Mất chỉ thị và dữ liệu khi tắt nguồn' (Loses instructions and data when power off). Các loại còn lại là 'Non-volatile' (bất khả biến)."
  },
  {
    "type": "mcq",
    "question": "Kỹ thuật 'Register Renaming' (Đổi tên thanh ghi) được sử dụng trong lập lịch động (dynamic scheduling) để loại bỏ chủ yếu các nguy cơ nào?",
    "options": [
      "Chỉ nguy cơ RAW (Read After Write)",
      "Nguy cơ cấu trúc (Structural hazards)",
      "Nguy cơ WAR (Write After Read) và WAW (Write After Write)",
      "Nguy cơ điều khiển (Control hazards)"
    ],
    "answer": 2,
    "explanation": "Giáo trình (Chương 2, Mục 2.4) giải thích rằng Register Renaming được giới thiệu để \"minimize WAW and WAR hazards\" (giảm thiểu nguy cơ WAW và WAR). Các nguy cơ này là 'name dependences' (phụ thuộc tên) chứ không phải 'true data dependences' (như RAW)."
  },
  {
    "type": "mcq",
    "question": "Kết quả của phép toán logic (1 XOR 1) AND (0 OR 1) là gì?",
    "options": [
      "0",
      "1"
    ],
    "answer": 0,
    "explanation": "Dựa trên bảng chân lý (Truth Table) từ Slide 02.pdf:\n1. (1 XOR 1) = 0 (XOR chỉ đúng khi các đầu vào khác nhau - trang 22)\n2. (0 OR 1) = 1 (OR chỉ sai khi tất cả là 0 - trang 10)\n3. (0 AND 1) = 0 (AND chỉ đúng khi tất cả là 1 - trang 9)\nKết quả cuối cùng là 0."
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 1), nếu một máy chủ có MTTF là 150.000 giờ và MTTR là 24 giờ, độ sẵn sàng (Availability) của nó là bao nhiêu?",
    "options": [
      "99.999%",
      "99.984%",
      "99.000%",
      "85.000%"
    ],
    "answer": 1,
    "explanation": "Giáo trình (Chương 1, Mục 1.7) định nghĩa: Module Availability = MTTF / (MTTF + MTTR).\nAvailability = 150,000 / (150,000 + 24) = 150,000 / 150,024 ≈ 0.9998400...\nĐổi sang phần trăm là 99.984%."
  },
  {
    "type": "fitb",
    "question": "Theo Slide 01.pdf (trang 19), mức thấp nhất (và chậm nhất) trong hệ thống phân cấp bộ nhớ là ......",
    "answer": "Tape (Băng từ)",
    "explanation": "Slide 01.pdf (trang 19) mô tả các mức của Memory Hierarchy, bắt đầu từ CPU Registers (nhanh nhất) và kết thúc ở mức 'Lower Level' (chậm nhất) là Tape (Băng từ)."
  },
  {
    "type": "fitb",
    "question": "Giáo trình (Chương 1) định nghĩa ...... là thời gian giữa lúc bắt đầu và lúc hoàn thành một sự kiện, ví dụ như một truy cập đĩa.",
    "answer": "Latency (Độ trễ)",
    "explanation": "Giáo trình (Chương 1, Mục 1.4) định nghĩa: 'In contrast, latency or response time is the time between the start and the completion of an event, such as milliseconds for a disk access.'"
  },
  {
    "type": "mcq",
    "question": "Trong Slide 02.pdf (trang 65), một D-Flip Flop (trái ngược với D-Latch) là một thiết bị được kích hoạt bởi:",
    "options": [
      "Cạnh (Edge triggered)",
      "Mức (Level triggered)",
      "Tín hiệu Reset",
      "Tín hiệu bất đồng bộ (Asynchronous)"
    ],
    "answer": 0,
    "explanation": "Slide 02.pdf (trang 65) định nghĩa: 'An edge triggered D-Latch is a D-Flip Flop' (Một D-Latch được kích hoạt bằng cạnh là một D-Flip Flop)."
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 2), mục đích chính của Reorder Buffer (ROB) trong 'hardware-based speculation' là gì?",
    "options": [
      "Để dự đoán địa chỉ nhánh.",
      "Để lưu trữ các thanh ghi đã đổi tên.",
      "Để giữ kết quả của các lệnh đã hoàn thành nhưng chưa 'commit', cho phép commit theo đúng thứ tự (in-order).",
      "Để thực hiện các phép toán số học."
    ],
    "answer": 2,
    "explanation": "Giáo trình (Chương 2, Mục 2.6) giải thích rằng Reorder Buffer (ROB) \"holds the result of an instruction between the time the operation... completes and the time the instruction commits.\" Điều này cho phép \"allow instructions to execute out of order but to force them to commit in order\"."
  },
  {
    "type": "msq",
    "question": "Theo Slide 01.pdf (trang 6), các thành phần chính của một 'Processor' (Bộ xử lý) là gì?",
    "options": [
      "Control (Điều khiển)",
      "Datapath (Đường đi dữ liệu)",
      "Memory (Bộ nhớ)",
      "Input (Đầu vào)"
    ],
    "answer": [0, 1],
    "explanation": "Slide 01.pdf (trang 6) trong sơ đồ 'Components of a Computer' cho thấy 'Processor' (Bộ xử lý) bao gồm 'Control' (Điều khiển) và 'Datapath' (Đường đi dữ liệu)."
  },
  {
    "type": "msq",
    "question": "Giáo trình (Chương 1) đề cập đến những xu hướng nào về chi phí (cost) trong sản xuất mạch tích hợp (IC)?",
    "options": [
      "Chi phí trên mỗi die (die cost) tăng gần như tuyến tính với diện tích die (die area).",
      "Chi phí trên mỗi die (die cost) tăng gần như theo bình phương của diện tích die (die area).",
      "Chi phí của một bộ mặt nạ (mask set) cho các quy trình chế tạo hiện đại có thể vượt quá 1 triệu đô la.",
      "Năng suất (Yield) tăng lên khi diện tích die tăng lên."
    ],
    "answer": [1, 2],
    "explanation": "Giáo trình (Chương 1, Mục 1.6) giải thích rằng 'the cost per die, grows roughly as the square of the die area'. Mục này cũng nêu rằng 'mask costs exceed $1 million'. Năng suất (Die yield) thực tế *giảm* khi diện tích die tăng lên."
  },
  {
    "type": "mcq",
    "question": "Phép toán (A + B) . (A + C) tương đương với phép toán nào theo luật phân phối (Distributive law) của Đại số Boolean?",
    "options": [
      "A . (B + C)",
      "A + (B . C)",
      "A . B + C",
      "A . C + B"
    ],
    "answer": 1,
    "explanation": "Slide 02.pdf (trang 15) liệt kê hai luật phân phối. Dạng thứ hai là: A + (B . C) = (A + B) . (A + C)."
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 2), kỹ thuật 'Loop Unrolling' (Trải vòng lặp) do trình biên dịch thực hiện có thể gặp phải hạn chế nào?",
    "options": [
      "Tăng áp lực lên thanh ghi (register pressure) do cần nhiều thanh ghi hơn.",
      "Luôn luôn làm giảm kích thước mã nguồn.",
      "Không thể áp dụng cho các vòng lặp có phụ thuộc.",
      "Chỉ hoạt động trên các kiến trúc VLIW."
    ],
    "answer": 0,
    "explanation": "Giáo trình (Chương 2, Mục 2.2) chỉ ra rằng một hạn chế của loop unrolling (ngoài code size) là 'potential shortfall in registers' (thiếu hụt thanh ghi tiềm ẩn), được gọi là 'register pressure' (áp lực thanh ghi)."
  },
  {
    "type": "fitb",
    "question": "Slide 01.pdf (trang 29) minh họa rằng Hợp ngữ (Assembly language) là sự biểu diễn ...... của các lệnh máy (machine instructions).",
    "answer": "văn bản (textual)",
    "explanation": "Slide 01.pdf (trang 30) mô tả Assembly language là 'Textual representation of instructions' (Biểu diễn văn bản của các lệnh)."
  },
  {
    "type": "fitb",
    "question": "Trong Giáo trình (Chương 1, Mục 1.8), thước đo hiệu năng (performance) duy nhất nhất quán và đáng tin cậy là ......",
    "answer": "thời gian thực thi (execution time)",
    "explanation": "Giáo trình (Chương 1, Mục 1.8) khẳng định: 'Our position is that the only consistent and reliable measure of performance is the execution time of real programs'."
  },
  {
    "type": "mcq",
    "question": "Số thập phân 5 (Decimal) được biểu diễn trong hệ nhị phân (Binary) là?",
    "options": [
      "100",
      "101",
      "110",
      "011"
    ],
    "answer": 1,
    "explanation": "Slide 02.pdf (trang 87-95) minh họa cách chuyển đổi 5 (thập phân) sang 101 (nhị phân) bằng cách chia liên tiếp cho 2 và lấy số dư."
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 1, Mục 1.8), khi tóm tắt hiệu năng của một bộ benchmark (benchmark suite) bằng cách sử dụng các tỷ lệ (ratios) như SPECRatio, nên sử dụng phép toán nào?",
    "options": [
      "Trung bình cộng (Arithmetic mean)",
      "Trung bình nhân (Geometric mean)",
      "Trung bình điều hòa (Harmonic mean)",
      "Tổng (Sum)"
    ],
    "answer": 1,
    "explanation": "Giáo trình (Chương 1, Mục 1.8) giải thích rằng vì SPECRatio là một tỷ lệ, 'the mean must be computed using the geometric mean' (trung bình phải được tính bằng trung bình nhân)."
  },
  {
    "type": "msq",
    "question": "Theo Slide 02.pdf (trang 83), các phương pháp biểu diễn số nguyên không dấu (unsigned integer) bao gồm:",
    "options": [
      "Standard binary (Nhị phân chuẩn)",
      "Octal (Bát phân)",
      "Hexadecimal (Thập lục phân)",
      "2's Complement (Bù 2)"
    ],
    "answer": [0, 1, 2],
    "explanation": "Slide 02.pdf (trang 83 và các trang tiếp theo) thảo luận về 'Unsigned integer representation'. Các trang 86, 116, 129 giới thiệu các hệ nhị phân (Binary), bát phân (Octal), và thập lục phân (Hexadecimal) như các phương pháp biểu diễn không dấu. Bù 2 là để biểu diễn số có dấu (signed)."
  },
  {
    "type": "msq",
    "question": "Giáo trình (Chương 2) mô tả các kỹ thuật của trình biên dịch (compiler) cơ bản để tăng ILP. Hai trong số các kỹ thuật đó là gì?",
    "options": [
      "Dự đoán nhánh (Branch prediction)",
      "Lập lịch pipeline (Pipeline scheduling)",
      "Trải vòng lặp (Loop unrolling)",
      "Đổi tên thanh ghi (Register renaming)"
    ],
    "answer": [1, 2],
    "explanation": "Giáo trình (Chương 2, Mục 2.2) có tiêu đề 'Basic Compiler Techniques for Exposing ILP' (Các kỹ thuật trình biên dịch cơ bản để bộc lộ ILP). Mục này thảo luận chi tiết về 'Basic Pipeline Scheduling' (Lập lịch pipeline cơ bản) và 'Loop Unrolling' (Trải vòng lặp)."
  },
  {
    "type": "mcq",
    "question": "Slide 01.pdf (trang 18) định nghĩa 'Non-volatile secondary memory' (Bộ nhớ thứ cấp bất khả biến) là loại bộ nhớ:",
    "options": [
      "Mất dữ liệu khi tắt nguồn, ví dụ như RAM.",
      "Không mất dữ liệu khi tắt nguồn, ví dụ như Magnetic disk (Đĩa từ) và Flash memory.",
      "Chỉ có thể đọc, không thể ghi, ví dụ như ROM.",
      "Nhanh nhất trong hệ thống, ví dụ như thanh ghi."
    ],
    "answer": 1,
    "explanation": "Slide 01.pdf (trang 18) định nghĩa 'Non-volatile secondary memory' là bộ nhớ không mất dữ liệu khi tắt nguồn, và đưa ra ví dụ là 'Magnetic disk' và 'Flash memory'."
  },
  {
    "type": "mcq",
    "question": "Giáo trình (Chương 1, Mục 1.5) chỉ ra rằng việc giảm điện áp (voltage) có tác động lớn nhất đến công suất động (dynamic power) vì công suất động tỷ lệ với:",
    "options": [
      "Điện áp (Voltage)",
      "Điện áp bình phương (Voltage^2)",
      "Tần số (Frequency)",
      "Điện dung (Capacitive load)"
    ],
    "answer": 1,
    "explanation": "Giáo trình (Chương 1, Mục 1.5) nêu rõ 'dynamic power and energy are greatly reduced by lowering the voltage' và đưa ra công thức Power_dynamic tỷ lệ với Voltage²."
  },
  {
    "type": "fitb",
    "question": "Một thanh ghi D-Flip Flop 8-bit được tạo thành từ ...... D-Flip Flop 1-bit.",
    "answer": "8",
    "explanation": "Slide 02.pdf (trang 72) cho thấy một 'Word' (từ) 4-bit được tạo thành từ 4 D-Flip Flop. Theo logic tương tự, một thanh ghi 8-bit sẽ được tạo thành từ 8 D-Flip Flop 1-bit hoạt động như một khối thống nhất."
  },
  {
    "type": "fitb",
    "question": "Giáo trình (Chương 2, Mục 2.1) định nghĩa sự phụ thuộc xảy ra khi lệnh j ghi vào một thanh ghi hoặc vị trí bộ nhớ mà lệnh i (trước đó) đọc là một ......",
    "answer": "antidependence (phụ thuộc ngược)",
    "explanation": "Giáo trình (Chương 2, Mục 2.1) định nghĩa: 'An antidependence between instruction i and instruction j occurs when instruction j writes a register or memory location that instruction i reads.' Đây là một loại 'name dependence' (phụ thuộc tên)."
  },
  {
    "type": "mcq",
    "question": "Theo Slide 01.pdf (trang 30), cấp độ mã nào (Level of Program Code) có tính trừu tượng gần với miền vấn đề (problem domain) nhất?",
    "options": [
      "Binary machine language (Ngôn ngữ máy nhị phân)",
      "Assembly language (Hợp ngữ)",
      "High-level language (Ngôn ngữ cấp cao)",
      "Microcode (Vi mã)"
    ],
    "answer": 2,
    "explanation": "Slide 01.pdf (trang 30) mô tả 'High-level language' (Ngôn ngữ cấp cao) là 'Level of abstraction closer to problem domain' (Mức độ trừu tượng gần hơn với miền vấn đề)."
  },
  {
    "type": "mcq",
    "question": "Giáo trình (Chương 2, Mục 2.7) định nghĩa kiến trúc VLIW (Very Long Instruction Word) là:",
    "options": [
      "Một bộ xử lý tự động phát hiện và thực thi song song các lệnh.",
      "Một bộ xử lý có khả năng đổi tên thanh ghi động.",
      "Một bộ xử lý phát hành một số lượng lệnh cố định được đóng gói như một lệnh lớn, với tính song song được chỉ định rõ ràng.",
      "Một bộ xử lý chỉ sử dụng vi mã."
    ],
    "answer": 2,
    "explanation": "Giáo trình (Chương 2, Mục 2.7) định nghĩa: 'VLIW processors... issue a fixed number of instructions formatted either as one large instruction or as a fixed instruction packet with the parallelism among instructions explicitly indicated by the instruction.'"
  },
  {
    "type": "msq",
    "question": "Theo Slide 02.pdf (trang 6), các tiên đề (axioms) của Đại số Boolean bao gồm:",
    "options": [
      "Hai hằng số Boolean (1 và 0)",
      "Các biến Boolean (A, B, X...)",
      "Các toán tử chính: NOT, AND, OR",
      "Toán tử XOR"
    ],
    "answer": [0, 1, 2],
    "explanation": "Slide 02.pdf (trang 6) liệt kê các tiên đề: Hai hằng số Boolean (1 và 0), Các biến Boolean, và 3 toán tử chính (3 primary Operators): NOT, AND, OR."
  },
  {
    "type": "msq",
    "question": "Giáo trình (Chương 1, Mục 1.2) phân biệt các lớp máy tính. Những đặc điểm nào sau đây mô tả đúng lớp 'Embedded computers' (Máy tính nhúng)?",
    "options": [
      "Luôn có hiệu năng cao nhất và bộ nhớ lớn nhất.",
      "Bị ràng buộc chặt chẽ về năng lượng/hiệu năng/chi phí (Stringent power/performance/cost constraints).",
      "Thường được ẩn như các thành phần của hệ thống khác.",
      "Chủ yếu dựa trên mạng (Network based)."
    ],
    "answer": [1, 2],
    "explanation": "Giáo trình (Chương 1, Mục 1.2) mô tả máy tính nhúng (Embedded computers) là 'Hidden as components of systems' (Bị ẩn như các thành phần của hệ thống) và có 'Stringent power/performance/cost constraints' (Các ràng buộc chặt chẽ về năng lượng/hiệu năng/chi phí)."
  },
  {
    "type": "mcq",
    "question": "Phép toán (A AND 1) OR (A AND 0) tương đương với?",
    "options": [
      "A",
      "0",
      "1",
      "NOT A"
    ],
    "answer": 0,
    "explanation": "Áp dụng Luật Định danh (Identity law) và Luật 0 và 1 (Zero and One laws) từ Slide 02.pdf (trang 14):\n1. (A AND 1) = A (Luật định danh)\n2. (A AND 0) = 0 (Luật 0 và 1)\n3. Biểu thức trở thành: A OR 0 = A (Luật định danh)"
  },
  {
    "type": "mcq",
    "question": "Theo Giáo trình (Chương 2, Mục 2.1), phụ thuộc điều khiển (control dependence) xác định:",
    "options": [
      "Thứ tự của một lệnh (i) so với một lệnh rẽ nhánh (branch) để đảm bảo lệnh (i) chỉ được thực thi khi cần thiết.",
      "Thứ tự của hai lệnh ghi vào cùng một thanh ghi.",
      "Thứ tự của một lệnh đọc và một lệnh ghi vào cùng một địa chỉ bộ nhớ.",
      "Tốc độ của đồng hồ hệ thống."
    ],
    "answer": 0,
    "explanation": "Giáo trình (Chương 2, Mục 2.1) định nghĩa: 'A control dependence determines the ordering of an instruction, i, with respect to a branch instruction so that the instruction i is executed in correct program order and only when it should be.'"
  },
  {
    "type": "fitb",
    "question": "Theo Slide 01.pdf (trang 18), bộ nhớ chính (Main memory) là loại bộ nhớ ...... (khả biến), nghĩa là nó mất dữ liệu khi tắt nguồn.",
    "answer": "volatile",
    "explanation": "Slide 01.pdf (trang 18) định nghĩa 'Volatile main memory' là 'Loses instructions and data when power off'."
  },
  {
    "type": "fitb",
    "question": "Nếu một hệ thống có MTTF là 200.000 giờ và MTTR là 100 giờ, thì ...... (Availability) của nó là 99.95%.",
    "answer": "Module availability",
    "explanation": "Giáo trình (Chương 1, Mục 1.7) cung cấp công thức: Module Availability = MTTF / (MTTF + MTTR). \nAvailability = 200,000 / (200,000 + 100) = 200,000 / 200,100 ≈ 0.9995 = 99.95%."
  },
  {
    "type": "msq",
    "question": "Phép toán XOR (Exclusive-OR) có những đặc điểm nào sau đây?",
    "options": [
      "Đầu ra là 1 nếu số lượng đầu vào 1 là số lẻ.",
      "Đầu ra là 1 nếu tất cả đầu vào là 1.",
      "Đầu ra là 1 chỉ khi hai đầu vào khác nhau (một 1, một 0).",
      "Đầu ra là 0 nếu hai đầu vào giống nhau (cùng 0 hoặc cùng 1)."
    ],
    "answer": [2, 3],
    "explanation": "Slide 02.pdf (trang 21-22) định nghĩa XOR: 'Output is 1 only if the two primary inputs are different' (Đầu ra là 1 chỉ khi hai đầu vào khác nhau). Bảng chân lý (trang 22) cho thấy A=0, B=0 thì KQ=0; A=1, B=1 thì KQ=0. Do đó, đầu ra là 0 nếu hai đầu vào giống nhau."
  },
  {
    "type": "msq",
    "question": "Theo Giáo trình (Chương 2, Mục 2.6), 'Hardware-based speculation' (Suy đoán dựa trên phần cứng) kết hợp ba ý tưởng chính nào?",
    "options": [
      "Dự đoán nhánh động (Dynamic branch prediction).",
      "Suy đoán (Speculation) để cho phép thực thi lệnh trước khi phụ thuộc điều khiển được giải quyết.",
      "Lập lịch động (Dynamic scheduling) để xử lý các khối cơ bản (basic blocks) khác nhau.",
      "Một bộ đệm ghi (Write buffer) đơn giản."
    ],
    "answer": [0, 1, 2],
    "explanation": "Giáo trình (Chương 2, Mục 2.6) nêu rõ: 'Hardware-based speculation combines three key ideas: dynamic branch prediction..., speculation to allow the execution of instructions before the control dependences are resolved..., and dynamic scheduling...'"
  }
]